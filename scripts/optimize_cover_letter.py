"""Run 8 iterations of cover letter optimization and select the best."""

from pathlib import Path
import sys
sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from agents.cover_letter.cover_letter_generator_agent import CoverLetterGeneratorAgent
from agents.cover_letter.hr_simulation_agent import HRSimulationAgent

job_title = 'AI Software Engineer'
company = 'Meta'
location = 'London, UK'

job_description = """
Meta is seeking a Software Engineer to join our team. The candidate is someone with experience working on maximizing performance of AI models on GPUs or custom silicon. This role involves applying these skills to solve some of the most crucial and exciting problems that exist on the web.

The AI Applications Engineering team is dedicated to maximizing training and inference performance of Generative AI (GenAI) and Recommendation models on Meta's Training and Inference Accelerator (MTIA). We employ innovative optimization and parallelization strategies to maximize training throughput for the next generations of GenAI and recommendation models. Additionally, we work cross-functionally with many partner teams to ensure end-to-end performance of large-scale pre-training and inference, enabling us to deliver the next generation of AI experiences more quickly to our users.

Responsibilities:
- Apply in depth knowledge of AI infrastructure and hardware acceleration techniques to build and optimize our intelligent AI systems that improve Meta's product and experiences
- Goal setting related to project impact, AI system design, and infrastructure efficiency
- Directly or influencing partners to deliver impact through thorough data analysis
- Drive large efforts across multiple teams
- Define use cases, and develop methodology & benchmarks to evaluate different approaches
- Apply in depth knowledge of how the AI infra interacts with the other systems around it

Minimum Qualifications:
- Bachelor's degree in computer science or a related STEM field
- Specialized experience in one or more of the following AI/deep learning domains: AI infrastructure, hardware accelerators, high performance computing, AI compilers, performance optimizations, GPU architecture, on-device optimization, AI frameworks (PyTorch), HW/SW co-design and numerics
- Experience developing AI algorithms in C/C++ or Python for large-scale AI applications

Preferred Qualifications:
- Master's degree/PhD in computer science or related STEM field and practical experience in AI development or accelerating AI models on AI accelerators
- Experience with distributed heterogeneous systems or on-device algorithm development
- Expertise in AI hardware accelerator architectures
- Experience with recommender and ranking models
- Experience in accelerating large AI models across multiple compute nodes
- Proven technical leadership experience
"""

style_notes = """
IMPORTANT CONTEXT:
This cover letter is being generated by a sophisticated multi-agent job application system designed and built by Alperen Turkmen himself. The system uses Gemini LLMs, PostgreSQL, Playwright automation, and includes discovery agents, scoring agents, and cover letter generation with iterative HR feedback loops.

This Meta AI role was discovered, scraped, scored, and matched through this automated pipeline - demonstrating exactly the kind of AI systems engineering Meta is looking for.

Make this cover letter compelling, confident, and technically impressive. Reference the multi-agent system subtly as proof of capability. This is meta - an AI system applying for an AI job!
"""

def main():
    generator = CoverLetterGeneratorAgent()
    hr = HRSimulationAgent()
    
    MAX_ITERATIONS = 8
    versions = []
    
    print('=' * 70)
    print('8-ITERATION COVER LETTER OPTIMIZATION')
    print('=' * 70)
    
    # Initial generation
    print(f'\n[Iteration 1] Generating initial cover letter...')
    letter = generator.generate(
        job_title=job_title,
        job_description=job_description,
        company=company,
        location=location,
        style_notes=style_notes,
        iteration=1,
    )
    
    for iteration in range(1, MAX_ITERATIONS + 1):
        print(f'\n[Iteration {iteration}] Evaluating...')
        
        feedback = hr.evaluate(
            cover_letter=letter,
            job_title=job_title,
            job_description=job_description,
            company=company,
            iteration=iteration,
        )
        
        score = feedback.get('score', 0)
        print(f'  Score: {score}/100')
        
        # Store this version
        versions.append({
            'iteration': iteration,
            'score': score,
            'letter': letter,
            'feedback': feedback,
        })
        
        if iteration < MAX_ITERATIONS:
            # Format feedback for revision
            positives = '\n'.join('- ' + p for p in feedback.get('positives', []))
            negatives = '\n'.join('- ' + n for n in feedback.get('negatives', []))
            suggestions = '\n'.join('- ' + s for s in feedback.get('fix_suggestions', []))
            
            feedback_text = f"""
HR FEEDBACK (Score: {score}/100):

POSITIVES (keep these):
{positives}

NEGATIVES (must fix):
{negatives}

SPECIFIC SUGGESTIONS (implement all):
{suggestions}

IMPORTANT: Address ALL negatives and implement ALL suggestions while preserving the positives. Make it more compelling.
"""
            print(f'  Revising for iteration {iteration + 1}...')
            letter = generator.revise(
                current_letter=letter,
                feedback=feedback_text,
                iteration=iteration + 1,
            )
    
    # Find best version
    best = max(versions, key=lambda x: x['score'])
    
    print('\n' + '=' * 70)
    print('SCORE PROGRESSION')
    print('=' * 70)
    for v in versions:
        marker = ' ★ BEST' if v['iteration'] == best['iteration'] else ''
        print(f"  Iteration {v['iteration']}: {v['score']}/100{marker}")
    
    print('\n' + '=' * 70)
    print(f"BEST COVER LETTER (Iteration {best['iteration']}, Score: {best['score']}/100)")
    print('=' * 70)
    print(best['letter'])
    print('=' * 70)
    
    print('\n' + '=' * 70)
    print('BEST VERSION - HR EVALUATION')
    print('=' * 70)
    print(f"Score: {best['score']}/100")
    print('\nPositives:')
    for p in best['feedback'].get('positives', []):
        print(f'  ✓ {p}')
    print('\nNegatives:')
    for n in best['feedback'].get('negatives', []):
        print(f'  ✗ {n}')
    print('=' * 70)
    
    # Save best version
    output_path = Path(__file__).resolve().parents[1] / 'data' / 'output' / 'best_cover_letter_meta.md'
    output_path.write_text(f"""# Cover Letter - Meta AI Software Engineer

**Score: {best['score']}/100** (Iteration {best['iteration']} of 8)

---

{best['letter']}
""")
    print(f'\n✓ Best version saved to: {output_path}')


if __name__ == "__main__":
    main()
